var bratik=function(n){"use strict";const u=Math.PI,b=u*2,A="close",m=(t,e)=>Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2)),z=(t,e,s)=>{if(s){const i=m(t,e),l=m(e,s),f=m(s,t);return Math.acos((i*i+l*l-f*f)/(2*i*l))}else return Math.atan2(e.y-t.y,e.x-t.x)},P=(t,e)=>{const s=e-t;return s>u&&s<b||s<0&&s>-u?-1:1};let v;const x=(t,e)=>{v=t.length;const s=t.map((i,l)=>{const f=t[(l-1+t.length)%t.length],a=t[(l+1)%t.length],g=m(i,a),d=m(f,i),S=w(f,i,a),T=1/Math.tan(S.main/2),N=e*T;return{...i,id:l,angles:S,vel:T,offset:N,radius:{size:e,x:i.x,y:i.y,hit:e},in:{x:i.x,y:i.y,length:d,rest:d},out:{x:i.x,y:i.y,length:g,rest:g},locked:!1,get prev(){return C(l,s)},get next(){return F(l,s)}}},[]);for(s.forEach(i=>{i.radius.hit=Math.min(i.out.length/(i.vel+i.next.vel),i.in.length/(i.vel+i.prev.vel))}),s.sort((i,l)=>i.radius.hit-l.radius.hit);v;)$(s[0],s,e),s.sort((i,l)=>i.locked&&!l.locked?1:!i.locked&&l.locked?-1:i.locked&&l.locked?0:i.radius.hit-l.radius.hit);return s.sort((i,l)=>i.id-l.id).forEach(E),s},$=(t,e,s)=>{if(!t.locked){const i=e.find(f=>f.id===(t.id-1+e.length)%e.length),l=e.find(f=>f.id===(t.id+1)%e.length);if(s>=t.radius.hit)if(t.radius.hit===l.radius.hit){const f=e.find(d=>d.id===(i.id-1+e.length)%e.length),a=e.find(d=>d.id===(l.id+1)%e.length),g=e.find(d=>d.id===(a.id+1)%e.length);t.radius.size=t.radius.hit,l.radius.size=t.radius.hit,l.locked=!0,t.locked=!0,v-=2,t.offset=t.radius.size*t.vel,l.offset=l.radius.size*l.vel,a.in.rest-=l.offset,l.out.rest-=l.offset,l.in.rest-=l.offset,l.in.rest-=t.offset,t.out.rest-=t.offset,t.in.rest-=t.offset,i.out.rest-=t.offset,a.radius.hit=Math.min(a.out.length/(a.vel+g.vel),a.in.rest/a.vel),i.radius.hit=Math.min(i.in.length/(i.vel+f.vel),i.out.rest/i.vel)}else if(t.radius.hit===i.radius.hit){const f=e.find(d=>d.id===(l.id+1)%e.length),a=e.find(d=>d.id===(i.id-1+e.length)%e.length),g=e.find(d=>d.id===(a.id-1+e.length)%e.length);t.radius.size=t.radius.hit,i.radius.size=t.radius.hit,t.locked=!0,i.locked=!0,v-=2,t.offset=t.radius.size*t.vel,i.offset=i.radius.size*i.vel,a.out.rest-=i.offset,i.in.rest-=i.offset,i.out.rest-=i.offset,i.out.rest-=t.offset,t.in.rest-=t.offset,t.out.rest-=t.offset,l.in.rest-=t.offset,a.radius.hit=Math.min(a.in.length/(a.vel+g.vel),a.out.rest/a.vel),l.radius.hit=Math.min(l.out.length/(l.vel+f.vel),l.in.rest/l.vel)}else i.locked&&!l.locked&&(t.radius.size=Math.min(t.in.rest/t.vel,t.out.length/(t.vel+l.vel),t.radius.size)),l.locked&&!i.locked&&(t.radius.size=Math.min(t.out.rest/t.vel,t.in.length/(t.vel+i.vel),t.radius.size)),l.locked&&i.locked&&(t.radius.size=Math.min(t.in.rest/t.vel,t.out.rest/t.vel,t.radius.size)),t.offset=t.radius.size*t.vel,i.out.rest-=t.offset,t.in.rest-=t.offset,t.out.rest-=t.offset,l.in.rest-=t.offset,t.locked=!0,v--;else t.offset=t.radius.size*t.vel,i.out.rest-=t.offset,t.in.rest-=t.offset,t.out.rest-=t.offset,l.in.rest-=t.offset,t.locked=!0,v--}},E=t=>{const e=t.radius.size/Math.sin(t.angles.main/2);t.radius.x=t.x+Math.cos(t.angles.bis)*e,t.radius.y=t.y+Math.sin(t.angles.bis)*e,t.in.x=t.x+Math.cos(t.angles.prev)*t.offset,t.in.y=t.y+Math.sin(t.angles.prev)*t.offset,t.out.x=t.x+Math.cos(t.angles.next)*t.offset,t.out.y=t.y+Math.sin(t.angles.next)*t.offset},w=(t,e,s)=>{const i=z(t,e,s),l=z(e,t),f=z(e,s),a=P(l,f),g=l+a*i/2;return{main:i,next:f,prev:l,bis:g,dir:a}},C=(t,e)=>e[(t-1+e.length)%e.length],F=(t,e)=>e[(t+1)%e.length];let h,c,o;n.ctx=void 0,n.frame=0,n.looping=!1;const I=(t,e,s)=>(o=document.createElement("canvas"),n.ctx=o.getContext("2d"),document.body.prepend(o),o.setAttribute("id",s||"canvas"),t?(h=t,c=e||h,o.setAttribute("style",`width:${h}px;height:${c}px;`),o.setAttribute("width",h.toString()),o.setAttribute("height",c.toString())):(o.setAttribute("style","width:100%;height:100%;"),{width:h,height:c}=o.getBoundingClientRect(),o.setAttribute("width",h.toString()),o.setAttribute("height",c.toString())),n.ctx.fillStyle="white",n.ctx.strokeStyle="black",n.ctx.imageSmoothingEnabled=!0,{width:h,height:c,ctx:n.ctx,canvas:o});let M=!1;const O=t=>{t==="close"&&n.ctx.closePath(),M?(M=!1,k()):n.ctx.beginPath()},q=(t,e)=>{M?n.ctx.lineTo(t,e):(M=!0,n.ctx.moveTo(t,e))},L=(t,e,s,i,l)=>{n.ctx.arcTo(t,e,s,i,l)},R=(t,e,s,i)=>{n.ctx.beginPath(),n.ctx.moveTo(t,e),n.ctx.lineTo(s,i),k()},U=(t,e,s=10)=>{n.ctx.beginPath(),n.ctx.arc(t,e,s,0,b),k()},j=(t,e,s=20,i=20,l)=>{n.ctx.beginPath(),l?(n.ctx.moveTo(t+l,e),n.ctx.arcTo(t+s,e,t+s,e+i,l),n.ctx.arcTo(t+s,e+i,t,e+i,l),n.ctx.arcTo(t,e+i,t,e,l),n.ctx.arcTo(t,e,t+s,e,l)):n.ctx.rect(t,e,s,i),k()},W=(t,e,s)=>{let i="",l=s||"",f=e||"sans-serif";if(typeof t=="number"&&(i=t.toString()+"px"),typeof t=="string"){const a=t.match(/^(\d+)([a-z%]*)\/?(\d*)([a-z%]*)$/);a&&(i=a[1],i+=a[2]?a[2]:"px",a[3]&&(i+=`/${a[3]}`,i+=a[4]?a[4]:"px"))}n.ctx.font=`${l} ${i} ${f}`.trim()};let _;const B=(t,e,s)=>{n.ctx.textAlign=t||"start",n.ctx.textBaseline=e||"alphabetic",_=s},D=(t,e,s,i)=>{n.ctx.fillText(t,e,s,i||_),n.ctx.strokeText(t,e,s,i||_)},k=()=>{n.ctx.fill(),n.ctx.stroke()},G=t=>{t===null?n.ctx.fillStyle="transparent":n.ctx.fillStyle=t},H=(t,e)=>{t===null?n.ctx.strokeStyle="transparent":n.ctx.strokeStyle=t,e!==void 0&&(n.ctx.lineWidth=e)},J=(t=0,e=0,s=h,i=c)=>{n.ctx.clearRect(t,e,s,i)};let y;n.stop=void 0;const K=t=>{n.looping=!0;let e;y=()=>{n.frame++,t(),e=requestAnimationFrame(y)},n.stop=()=>{n.looping=!1,cancelAnimationFrame(e)},y()};return n.CLOSE=A,n.PI=u,n.TAU=b,n.arc=L,n.circle=U,n.clear=J,n.draw=k,n.fill=G,n.font=W,n.getcanvas=I,n.line=R,n.loop=K,n.rect=j,n.round_shape=x,n.settext=B,n.shape=O,n.stroke=H,n.text=D,n.vertex=q,Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}}),n}({});
